<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jdqm.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

  <meta name="description" content="上一篇文章已经介绍了广播的类型，如何注册广播，如何发送广播以及使用过程应该注意的一些点。本文将从源码的角度来分析注册、发送、执行广播的过程。">
<meta property="og:type" content="website">
<meta property="og:title" content="Android广播工作过程分析">
<meta property="og:url" content="https://jdqm.github.io/2017/09/26/broadcast-analysis/index.html">
<meta property="og:site_name" content="Jdqm Blog">
<meta property="og:description" content="上一篇文章已经介绍了广播的类型，如何注册广播，如何发送广播以及使用过程应该注意的一些点。本文将从源码的角度来分析注册、发送、执行广播的过程。">
<meta property="og:locale">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3631399-459b001ca827c0b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3631399-fa0a479ed313f299.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3631399-3ac33d85dfefa157.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2017-09-26T15:17:22.000Z">
<meta property="article:modified_time" content="2017-10-20T15:17:22.000Z">
<meta property="article:author" content="Jdqm">
<meta property="article:tag" content="-broadcast">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/3631399-459b001ca827c0b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">


<link rel="canonical" href="https://jdqm.github.io/2017/09/26/broadcast-analysis/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"https://jdqm.github.io/2017/09/26/broadcast-analysis/","path":"2017/09/26/broadcast-analysis/","title":"Android广播工作过程分析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Android广播工作过程分析 | Jdqm Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Jdqm Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">正直、善良、脚踏实地</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-%E9%9D%99%E6%80%81%E5%B9%BF%E6%92%AD%E6%B3%A8%E5%86%8C"><span class="nav-number">1.</span> <span class="nav-text">一.静态广播注册</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%B9%BF%E6%92%AD"><span class="nav-number">2.</span> <span class="nav-text">二.动态注册广播</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-%E5%8F%91%E9%80%81%E5%B9%BF%E6%92%AD"><span class="nav-number">3.</span> <span class="nav-text">三.发送广播</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">4.</span> <span class="nav-text">三.总结：</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jdqm</p>
  <div class="site-description" itemprop="description">I promise you.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://jdqm.github.io/2017/09/26/broadcast-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jdqm">
      <meta itemprop="description" content="I promise you.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jdqm Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android广播工作过程分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-09-26 23:17:22" itemprop="dateCreated datePublished" datetime="2017-09-26T23:17:22+08:00">2017-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2017-10-20 23:17:22" itemprop="dateModified" datetime="2017-10-20T23:17:22+08:00">2017-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/626245eb80a0">上一篇文章</a>已经介绍了广播的类型，如何注册广播，如何发送广播以及使用过程应该注意的一些点。本文将从源码的角度来分析注册、发送、执行广播的过程。</p>
<span id="more"></span>

<h1 id="一-静态广播注册"><a href="#一-静态广播注册" class="headerlink" title="一.静态广播注册"></a>一.静态广播注册</h1><p>静态注册指的是在AndroidManifest.xml中注册的广播，这些册信息的维护主要有两个过程：系统启动的时候扫描系统中安装的apk的注册信息，安装、卸载的时候更新注册信息。</p>
<p>当系统启动的时候会启动PackageManagerService，从其main方法开始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static PackageManagerService main(Context context, Installer installer,</span><br><span class="line">        boolean factoryTest, boolean onlyCore) &#123;</span><br><span class="line">    // Self-check for initial settings.</span><br><span class="line">    PackageManagerServiceCompilerMapping.checkProperties();</span><br><span class="line">    </span><br><span class="line">    //创建了一个PackageManagerService实例</span><br><span class="line">    PackageManagerService m = new PackageManagerService(context, installer,</span><br><span class="line">            factoryTest, onlyCore);</span><br><span class="line">    m.enableSystemUserPackages();</span><br><span class="line">    </span><br><span class="line">    //注册这个Service</span><br><span class="line">    ServiceManager.addService(&quot;package&quot;, m);</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的main方法主要通过它的构造方法创建了一个实例，并注册了这个Service，它的构造方法实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public PackageManagerService(Context context, Installer installer,</span><br><span class="line">        boolean factoryTest, boolean onlyCore) &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    synchronized (mPackages) &#123;</span><br><span class="line">        ......</span><br><span class="line">        File dataDir = Environment.getDataDirectory();</span><br><span class="line">        mAppInstallDir = new File(dataDir, &quot;app&quot;);</span><br><span class="line">        mAppLib32InstallDir = new File(dataDir, &quot;app-lib&quot;);</span><br><span class="line">        mEphemeralInstallDir = new File(dataDir, &quot;app-ephemeral&quot;);</span><br><span class="line">        mAsecInternalPath = new File(dataDir, &quot;app-asec&quot;).getPath();</span><br><span class="line">        mDrmAppPrivateInstallDir = new File(dataDir, &quot;app-private&quot;);</span><br><span class="line">        ......</span><br><span class="line">        // Collect ordinary system packages.</span><br><span class="line">        final File systemAppDir = new File(Environment.getRootDirectory(), &quot;app&quot;);</span><br><span class="line">        scanDirTracedLI(systemAppDir, mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);</span><br><span class="line">        //扫描其他路径            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法中的代码比较多，这里只保留了部分关键代码，从代码中的扫描的路径可以了解到Android系统中的应用都安装在哪，这里只分析扫描系统应用的过程，即&#x2F;system&#x2F;app这个目录，其他路径类似。这个过程涉及到的方法比较多，先上一张时序序图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3631399-459b001ca827c0b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="静态注册广播时序图"></p>
<p>构造方法之后，沿着路径往下到 scanPackageLI 方法才有我们比较关心的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  Scans a package and returns the newly parsed package.</span><br><span class="line"> *  Returns &#123;@code null&#125; in case of errors and the error code is stored in mLastScanError</span><br><span class="line"> */</span><br><span class="line">private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags,</span><br><span class="line">        long currentTime, UserHandle user) throws PackageManagerException &#123;</span><br><span class="line">    if (DEBUG_INSTALL) Slog.d(TAG, &quot;Parsing: &quot; + scanFile);</span><br><span class="line">    PackageParser pp = new PackageParser();</span><br><span class="line">    pp.setSeparateProcesses(mSeparateProcesses);</span><br><span class="line">    pp.setOnlyCoreApps(mOnlyCore);</span><br><span class="line">    pp.setDisplayMetrics(mMetrics);</span><br><span class="line"></span><br><span class="line">    if ((scanFlags &amp; SCAN_TRUSTED_OVERLAY) != 0) &#123;</span><br><span class="line">        parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;parsePackage&quot;);</span><br><span class="line">    final PackageParser.Package pkg;</span><br><span class="line">    try &#123;</span><br><span class="line">    </span><br><span class="line">        //这里调用了PackageParser的parsePackage方法来解析apk文件</span><br><span class="line">        pkg = pp.parsePackage(scanFile, parseFlags);</span><br><span class="line">    &#125; catch (PackageParserException e) &#123;</span><br><span class="line">        throw PackageManagerException.from(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //最后又调用一个重载方法</span><br><span class="line">    return scanPackageLI(pkg, scanFile, parseFlags, scanFlags, currentTime, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法里主要调用了两个方法：PackageParser的parsePackage方法和一个重载的scanPackageLI方法，按照顺序，先看parsePackage方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Package parsePackage(File packageFile, int flags) throws PackageParserException &#123;</span><br><span class="line">    if (packageFile.isDirectory()) &#123;</span><br><span class="line">        return parseClusterPackage(packageFile, flags);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return parseMonolithicPackage(packageFile, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法比较简单，区分文件和目录来调用不同的方法，这里研究parseClusterPackage这条路径（路径参考上面的时序图），沿着这条路径往下，直到parseBaseApplication方法，这里有我们所关心的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Parse the &#123;@code application&#125; XML tree at the current parse location in a</span><br><span class="line"> * &lt;em&gt;base APK&lt;/em&gt; manifest.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * When adding new features, carefully consider if they should also be</span><br><span class="line"> * supported by split APKs.</span><br><span class="line"> */</span><br><span class="line">private boolean parseBaseApplication(Package owner, Resources res,</span><br><span class="line">        XmlResourceParser parser, int flags, String[] outError)</span><br><span class="line">    throws XmlPullParserException, IOException &#123;</span><br><span class="line">    TypedArray sa = res.obtainAttributes(parser,</span><br><span class="line">                com.android.internal.R.styleable.AndroidManifestApplication);</span><br><span class="line">                </span><br><span class="line">    //省略部分非关键代码</span><br><span class="line">    ....</span><br><span class="line">    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">                &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123;</span><br><span class="line">            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String tagName = parser.getName();</span><br><span class="line">            if (tagName.equals(&quot;activity&quot;)) &#123;</span><br><span class="line">                Activity a = parseActivity(owner, res, parser, flags, outError, false,</span><br><span class="line">                        owner.baseHardwareAccelerated);</span><br><span class="line">                if (a == null) &#123;</span><br><span class="line">                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                owner.activities.add(a);</span><br><span class="line">            </span><br><span class="line">            //解析receiver节点并保存到owner.receivers</span><br><span class="line">            &#125; else if (tagName.equals(&quot;receiver&quot;)) &#123;</span><br><span class="line">                Activity a = parseActivity(owner, res, parser, flags, outError, true, false);</span><br><span class="line">                if (a == null) &#123;</span><br><span class="line">                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                owner.receivers.add(a);</span><br><span class="line">            &#125;    </span><br><span class="line">            </span><br><span class="line">            //省略解析其他组件分支的代码</span><br><span class="line">            ......</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>
<p>可以看到，原来是解析各个apk文件的AndroidManifest.xml文件中所有注册的receiver，并且其添加到Package的成员变量receivers中，这样我们在PMS中拿到Package对象就能得到这个应用的所用静态注册的广播。接下来就回到了PMS中（通常跟踪源码到返回的时候意味着离目标也已经不远了）。</p>
<p>当返回到PMS后，又调用了一个重载的scanPackageLI方法，沿着路径往下，到scanPackageDirtyLI方法又出现关键代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg,</span><br><span class="line">            final int policyFlags, final int scanFlags, long currentTime, UserHandle user)</span><br><span class="line">            throws PackageManagerException &#123;</span><br><span class="line">    ....        </span><br><span class="line">    //省略其他非关键代码</span><br><span class="line">    </span><br><span class="line">    //这个pkg就是刚才PackageParser中解析得到的</span><br><span class="line">    N = pkg.receivers.size();</span><br><span class="line">    r = null;</span><br><span class="line">    for (i=0; i&lt;N; i++) &#123;</span><br><span class="line">        PackageParser.Activity a = pkg.receivers.get(i);</span><br><span class="line">        a.info.processName = fixProcessName(pkg.applicationInfo.processName,</span><br><span class="line">                a.info.processName, pkg.applicationInfo.uid);</span><br><span class="line">        //将所有静态注册的广播添加到mReceivers集合中        </span><br><span class="line">        mReceivers.addActivity(a, &quot;receiver&quot;);</span><br><span class="line">        if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123;</span><br><span class="line">            if (r == null) &#123;</span><br><span class="line">                r = new StringBuilder(256);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                r.append(&#x27; &#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">            r.append(a.info.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>
<p>看到这里终于松了一口气，原来所有的静态注册的广播最终是保存在PMS的成员变量mReceivers中，当发送广播时，AMS就会到这里来查询所有匹配的静态广播接收者，进而将广播发送给它们。下面的就是AMS中查询静态广播接受者的代码。</p>
<h1 id="二-动态注册广播"><a href="#二-动态注册广播" class="headerlink" title="二.动态注册广播"></a>二.动态注册广播</h1><p>动态注册广播我们通常需要这么做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = new IntentFilter(&quot;jdqm.intent.action.TEST&quot;);</span><br><span class="line">registerReceiver(receiver, filter);</span><br></pre></td></tr></table></figure>
<p>从调用context.registerReceiver方法到注册完成的大致的过程为：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3631399-fa0a479ed313f299.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动态注册广播时序图"></p>
<p>从ContextWapper的registerReceiver方法开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Intent registerReceiver(</span><br><span class="line">    BroadcastReceiver receiver, IntentFilter filter) &#123;</span><br><span class="line">    return mBase.registerReceiver(receiver, filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用了mBase的registerReceiver方法，这个mBase实际上是ContextImp的实例，ContextImp的registerReceiver方法也是将处理逻辑放到了该类的registerReceiverInternal方法中，该方法的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</span><br><span class="line">        IntentFilter filter, String broadcastPermission,</span><br><span class="line">        Handler scheduler, Context context) &#123;</span><br><span class="line">    //使用IItentReceiver（这是一个Binder对象）来中转实现跨进程通信    </span><br><span class="line">    IIntentReceiver rd = null;</span><br><span class="line">    if (receiver != null) &#123;</span><br><span class="line">    </span><br><span class="line">        //mPackageInfo是LoadedApk的实例</span><br><span class="line">        if (mPackageInfo != null &amp;&amp; context != null) &#123;</span><br><span class="line">            if (scheduler == null) &#123;</span><br><span class="line">                //这个Handler是主线程中mH</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //通过getReceiverDispatcher获取对应的IItentReceiver对象</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (scheduler == null) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = new LoadedApk.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, null, true).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        //通过Binder机制，向AMS发起注册请求，后续的逻辑就到AMS中了</span><br><span class="line">        final Intent intent = ActivityManagerNative.getDefault().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName,</span><br><span class="line">                rd, filter, broadcastPermission, userId);</span><br><span class="line">        if (intent != null) &#123;</span><br><span class="line">            intent.setExtrasClassLoader(getClassLoader());</span><br><span class="line">            intent.prepareToEnterProcess();</span><br><span class="line">        &#125;</span><br><span class="line">        return intent;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中通过调用getReceiverDispatcher方法，将广播记录在LoadedApk的成员变量mReceivers中。另外 ActivityManagerNative.getDefault()得到的是ActivityManagerService在客户端的一个代理对象，通过它我们就可以调用ActivityManagerService的registerReceiver方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public Intent registerReceiver(IApplicationThread caller, String callerPackage,</span><br><span class="line">        IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123;</span><br><span class="line">    ......</span><br><span class="line">    //省略前面代码</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (callerApp != null &amp;&amp; (callerApp.thread == null</span><br><span class="line">                || callerApp.thread.asBinder() != caller.asBinder())) &#123;</span><br><span class="line">            // Original caller already died</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">        if (rl == null) &#123;</span><br><span class="line">            rl = new ReceiverList(this, callerApp, callingPid, callingUid,</span><br><span class="line">                    userId, receiver);</span><br><span class="line">            if (rl.app != null) &#123;</span><br><span class="line">                rl.app.receivers.add(rl);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    receiver.asBinder().linkToDeath(rl, 0);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    return sticky;</span><br><span class="line">                &#125;</span><br><span class="line">                rl.linkedToDeath = true;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //动态注册的广播都保存在这个集合中</span><br><span class="line">            mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line">        &#125; else if (rl.uid != callingUid) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;Receiver requested to register for uid &quot; + callingUid</span><br><span class="line">                    + &quot; was previously registered for uid &quot; + rl.uid);</span><br><span class="line">        &#125; else if (rl.pid != callingPid) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;Receiver requested to register for pid &quot; + callingPid</span><br><span class="line">                    + &quot; was previously registered for pid &quot; + rl.pid);</span><br><span class="line">        &#125; else if (rl.userId != userId) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;Receiver requested to register for user &quot; + userId</span><br><span class="line">                    + &quot; was previously registered for user &quot; + rl.userId);</span><br><span class="line">        &#125;</span><br><span class="line">        BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,</span><br><span class="line">                permission, callingUid, userId);</span><br><span class="line">                </span><br><span class="line">        //关联IntentFilter        </span><br><span class="line">        rl.add(bf);</span><br><span class="line">        if (!bf.debugCheck()) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;==&gt; For Dynamic broadcast&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mReceiverResolver.addFilter(bf);</span><br><span class="line">        //省略后面代码</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里我们得出结论：动态注册的广播存储在AMS的成员变量mRegisteredReceivers中。</p>
<h1 id="三-发送广播"><a href="#三-发送广播" class="headerlink" title="三.发送广播"></a>三.发送广播</h1><p>发送广播过程的时序图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3631399-3ac33d85dfefa157.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发送广播时序图"></p>
<p>首先从ContextWrapper#sendBroadcast(Intent)方法开始.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void sendBroadcast(Intent intent) &#123;</span><br><span class="line">    //ContextImp: mBase</span><br><span class="line">    mBase.sendBroadcast(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ContextImp#sendBroadcast(Intent)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void sendBroadcast(Intent intent) &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    //这个resolvedType实际上是MIME类型</span><br><span class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">    try &#123;</span><br><span class="line">        intent.prepareToLeaveProcess(this);</span><br><span class="line">        </span><br><span class="line">        //通过Binder机制，向AMS发起请求</span><br><span class="line">        ActivityManagerNative.getDefault().broadcastIntent(</span><br><span class="line">                mMainThread.getApplicationThread(), intent, resolvedType, null,</span><br><span class="line">                Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,</span><br><span class="line">                getUserId());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面提到过ActivityManagerNative.getDefault()返回的是AMS在客户端的代理对象，通过它来调用AMS#broadcastIntent方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final int broadcastIntent(IApplicationThread caller,</span><br><span class="line">        Intent intent, String resolvedType, IIntentReceiver resultTo,</span><br><span class="line">        int resultCode, String resultData, Bundle resultExtras,</span><br><span class="line">        String[] requiredPermissions, int appOp, Bundle bOptions,</span><br><span class="line">        boolean serialized, boolean sticky, int userId) &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;broadcastIntent&quot;);</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        intent = verifyBroadcastLocked(intent);</span><br><span class="line">        final ProcessRecord callerApp = getRecordForAppLocked(caller);</span><br><span class="line">        final int callingPid = Binder.getCallingPid();</span><br><span class="line">        final int callingUid = Binder.getCallingUid();</span><br><span class="line">        final long origId = Binder.clearCallingIdentity();</span><br><span class="line">        </span><br><span class="line">        //进一步调用broadcastIntentLocked来处理</span><br><span class="line">        int res = broadcastIntentLocked(callerApp,</span><br><span class="line">                callerApp != null ? callerApp.info.packageName : null,</span><br><span class="line">                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,</span><br><span class="line">                requiredPermissions, appOp, bOptions, serialized, sticky,</span><br><span class="line">                callingPid, callingUid, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在这个方法内部又进一步调用broadcastIntentLocked来处理，这个方法代码很多，下面只列出部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">//Android3.1之后，默认情况下，Intent会添加了下面这个flag,所以默认情况下不会启动处于停止状态的应用。</span><br><span class="line">// By default broadcasts do not go to stopped apps.</span><br><span class="line">intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">// Figure out who all will receive this broadcast.</span><br><span class="line">List receivers = null;</span><br><span class="line">List&lt;BroadcastFilter&gt; registeredReceivers = null;</span><br><span class="line">// Need to resolve the intent to interested receivers...</span><br><span class="line">if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class="line">         == 0) &#123;</span><br><span class="line">    //收集匹配静态注册的广播接收者    </span><br><span class="line">    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">&#125;</span><br><span class="line">if (intent.getComponent() == null) &#123;</span><br><span class="line">    if (userId == UserHandle.USER_ALL &amp;&amp; callingUid == Process.SHELL_UID) &#123;</span><br><span class="line">        // Query one target user at a time, excluding shell-restricted users</span><br><span class="line">        for (int i = 0; i &lt; users.length; i++) &#123;</span><br><span class="line">            if (mUserController.hasUserRestriction(</span><br><span class="line">                    UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;BroadcastFilter&gt; registeredReceiversForUser =</span><br><span class="line">                    mReceiverReHHsolver.queryIntent(intent,</span><br><span class="line">                            resolvedType, false, users[i]);</span><br><span class="line">            if (registeredReceivers == null) &#123;</span><br><span class="line">                registeredReceivers = registeredReceiversForUser;</span><br><span class="line">            &#125; else if (registeredReceiversForUser != null) &#123;</span><br><span class="line">                registeredReceivers.addAll(registeredReceiversForUser);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //收集匹配动态注册的广播接受者</span><br><span class="line">        registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">                resolvedType, false, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">//动态注册的无序广播</span><br><span class="line">BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">        callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,</span><br><span class="line">        appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,</span><br><span class="line">        resultExtras, ordered, sticky, false, userId);</span><br><span class="line">if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing parallel broadcast &quot; + r);</span><br><span class="line">final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);</span><br><span class="line">if (!replaced) &#123;</span><br><span class="line">   //将动态注册的无序广播添加的无序广播队列</span><br><span class="line">    queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">    queue.scheduleBroadcastsLocked();</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">//receivers保存的是所有的静态广播，动态注册的有序广播</span><br><span class="line">if ((receivers != null &amp;&amp; receivers.size() &gt; 0)</span><br><span class="line">        || resultTo != null) &#123;</span><br><span class="line">    BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">            callerPackage, callingPid, callingUid, resolvedType,</span><br><span class="line">            requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">            resultData, resultExtras, ordered, sticky, false, userId);</span><br><span class="line"></span><br><span class="line">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing ordered broadcast &quot; + r</span><br><span class="line">            + &quot;: prev had &quot; + queue.mOrderedBroadcasts.size());</span><br><span class="line">    if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">            &quot;Enqueueing broadcast &quot; + r.intent.getAction());</span><br><span class="line"></span><br><span class="line">    boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line">    if (!replaced) &#123;</span><br><span class="line">        //将构造的BroadcastRecord添加的有序广播的队列</span><br><span class="line">        queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">        queue.scheduleBroadcastsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // There was nobody interested in the broadcast, but we still want to record</span><br><span class="line">    // that it happened.</span><br><span class="line">    if (intent.getComponent() == null &amp;&amp; intent.getPackage() == null</span><br><span class="line">            &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123;</span><br><span class="line">        // This was an implicit broadcast... let&#x27;s record it for posterity.</span><br><span class="line">        addBroadcastStatLocked(intent.getAction(), callerPackage, 0, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这方法的实现可以看到，首先收集了所有的符合的动态注册、静态注册的接收者，然后将动态无序广播、所有静态和动态有序包装成两个BroadcastRecord对象，添加到BroadcastQueue的两个集合中，这两个集合是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final ArrayList&lt;BroadcastRecord&gt; mParallelBroadcasts = new ArrayList&lt;&gt;();</span><br><span class="line">final ArrayList&lt;BroadcastRecord&gt; mOrderedBroadcasts = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>然后调用用BroadcastQueue的scheduleBroadcastsLocked方法进处理这两个集合。scheduleBroadcastsLocked方法的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleBroadcastsLocked() &#123;</span><br><span class="line">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;</span><br><span class="line">            + mQueueName + &quot;]: current=&quot;</span><br><span class="line">            + mBroadcastsScheduled);</span><br><span class="line"></span><br><span class="line">    if (mBroadcastsScheduled) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</span><br><span class="line">    mBroadcastsScheduled = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里逻辑也很简单，通过mHandler发送了一条BROADCAST_INTENT_MSG消息，这个Handler的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">final BroadcastHandler mHandler;</span><br><span class="line"></span><br><span class="line">private final class BroadcastHandler extends Handler &#123;</span><br><span class="line">    public BroadcastHandler(Looper looper) &#123;</span><br><span class="line">        super(looper, null, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case BROADCAST_INTENT_MSG: &#123;</span><br><span class="line">                if (DEBUG_BROADCAST) Slog.v(</span><br><span class="line">                        TAG_BROADCAST, &quot;Received BROADCAST_INTENT_MSG&quot;);</span><br><span class="line">                //关键代码</span><br><span class="line">                processNextBroadcast(true);</span><br><span class="line">            &#125; break;</span><br><span class="line">            case BROADCAST_TIMEOUT_MSG: &#123;</span><br><span class="line">                synchronized (mService) &#123;</span><br><span class="line">                    broadcastTimeoutLocked(true);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; break;</span><br><span class="line">            case SCHEDULE_TEMP_WHITELIST_MSG: &#123;</span><br><span class="line">                DeviceIdleController.LocalService dic = mService.mLocalDeviceIdleController;</span><br><span class="line">                if (dic != null) &#123;</span><br><span class="line">                    dic.addPowerSaveTempWhitelistAppDirect(UserHandle.getAppId(msg.arg1),</span><br><span class="line">                            msg.arg2, true, (String)msg.obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以发现，调用了processNextBroadcast方法来处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">final void processNextBroadcast(boolean fromMsg) &#123;</span><br><span class="line">    synchronized(mService) &#123;</span><br><span class="line">        BroadcastRecord r;</span><br><span class="line">        mService.updateCpuStats();</span><br><span class="line">        if (fromMsg) &#123;</span><br><span class="line">            mBroadcastsScheduled = false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //首先处理mParallelBroadcasts这个集合，这意味着mParallelBroadcasts集合的广播接受者比mOrderedBroadcasts集合的广播接收者先收到广播</span><br><span class="line">        // First, deliver any non-serialized broadcasts right away.</span><br><span class="line">        while (mParallelBroadcasts.size() &gt; 0) &#123;</span><br><span class="line">        </span><br><span class="line">           //一个广播对应着一个BroadcastRecord实例</span><br><span class="line">            r = mParallelBroadcasts.remove(0);</span><br><span class="line">            r.dispatchTime = SystemClock.uptimeMillis();</span><br><span class="line">            r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">            final int N = r.receivers.size();</span><br><span class="line">            if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Processing parallel broadcast [&quot;</span><br><span class="line">                    + mQueueName + &quot;] &quot; + r);</span><br><span class="line">            for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                Object target = r.receivers.get(i);</span><br><span class="line">                if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                        &quot;Delivering non-ordered on [&quot; + mQueueName + &quot;] to registered &quot;</span><br><span class="line">                        + target + &quot;: &quot; + r);</span><br><span class="line">                //动态注册的无序广播        </span><br><span class="line">                deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false, i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //记录广播的历史</span><br><span class="line">            addBroadcastToHistoryLocked(r);</span><br><span class="line">            if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Done with parallel broadcast [&quot;</span><br><span class="line">                    + mQueueName + &quot;] &quot; + r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Now take care of the next serialized one...</span><br><span class="line"></span><br><span class="line">        // If we are waiting for a process to come up to handle the next</span><br><span class="line">        // broadcast, then do nothing at this point.  Just in case, we</span><br><span class="line">        // check that the process we&#x27;re waiting for still exists.</span><br><span class="line">        if (mPendingBroadcast != null) &#123;</span><br><span class="line">            if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">                    &quot;processNextBroadcast [&quot; + mQueueName + &quot;]: waiting for &quot;</span><br><span class="line">                    + mPendingBroadcast.curApp);</span><br><span class="line"></span><br><span class="line">            boolean isDead;</span><br><span class="line">            synchronized (mService.mPidsSelfLocked) &#123;</span><br><span class="line">                ProcessRecord proc = mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);</span><br><span class="line">                isDead = proc == null || proc.crashing;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!isDead) &#123;</span><br><span class="line">                // It&#x27;s still alive, so keep waiting</span><br><span class="line">                return;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Slog.w(TAG, &quot;pending app  [&quot;</span><br><span class="line">                        + mQueueName + &quot;]&quot; + mPendingBroadcast.curApp</span><br><span class="line">                        + &quot; died before responding to broadcast&quot;);</span><br><span class="line">                mPendingBroadcast.state = BroadcastRecord.IDLE;</span><br><span class="line">                mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex;</span><br><span class="line">                mPendingBroadcast = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean looped = false;</span><br><span class="line">        </span><br><span class="line">        do &#123;</span><br><span class="line">            if (mOrderedBroadcasts.size() == 0) &#123;</span><br><span class="line">            ......   </span><br><span class="line">        &#125; while (r == null);</span><br><span class="line">        </span><br><span class="line">        .....</span><br><span class="line">        </span><br><span class="line">        // Is this receiver&#x27;s application already running?</span><br><span class="line">        if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                        info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);</span><br><span class="line">                //当进程跑起来后        </span><br><span class="line">                processCurBroadcastLocked(r, app);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Exception when sending broadcast to &quot;</span><br><span class="line">                      + r.curComponent, e);</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Failed sending broadcast to &quot;</span><br><span class="line">                        + r.curComponent + &quot; with &quot; + r.intent, e);</span><br><span class="line">                // If some unexpected exception happened, just skip</span><br><span class="line">                // this broadcast.  At this point we are not in the call</span><br><span class="line">                // from a client, so throwing an exception out from here</span><br><span class="line">                // will crash the entire system instead of just whoever</span><br><span class="line">                // sent the broadcast.</span><br><span class="line">                logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">                finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                        r.resultExtras, r.resultAbort, false);</span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line">                // We need to reset the state if we failed to start the receiver.</span><br><span class="line">                r.state = BroadcastRecord.IDLE;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If a dead object exception was thrown -- fall through to</span><br><span class="line">            // restart the application.</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，先处理了mParallelBroadcasts，然后才处理mOrderedBroadcasts，这两个集合的处理逻辑是有些差异的，按顺序先看mParallelBroadcasts，这个集合是通过deliverToRegisteredReceiverLocked来处理，而这个方法又进一步调用了performReceiveLocked方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</span><br><span class="line">        Intent intent, int resultCode, String data, Bundle extras,</span><br><span class="line">        boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;</span><br><span class="line">    // Send the intent to the receiver asynchronously using one-way binder calls.</span><br><span class="line">    if (app != null) &#123;</span><br><span class="line">        if (app.thread != null) &#123;</span><br><span class="line">            // If we have an app thread, do the call through that so it is</span><br><span class="line">            // correctly ordered with other one-way calls.</span><br><span class="line">            try &#123;</span><br><span class="line">                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">                        data, extras, ordered, sticky, sendingUser, app.repProcState);</span><br><span class="line">            // TODO: Uncomment this when (b/28322359) is fixed and we aren&#x27;t getting</span><br><span class="line">            // DeadObjectException when the process isn&#x27;t actually dead.</span><br><span class="line">            //&#125; catch (DeadObjectException ex) &#123;</span><br><span class="line">            // Failed to call into the process.  It&#x27;s dying so just let it die and move on.</span><br><span class="line">            //    throw ex;</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                // Failed to call into the process. It&#x27;s either dying or wedged. Kill it gently.</span><br><span class="line">                synchronized (mService) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;Can&#x27;t deliver broadcast to &quot; + app.processName</span><br><span class="line">                            + &quot; (pid &quot; + app.pid + &quot;). Crashing it.&quot;);</span><br><span class="line">                    app.scheduleCrash(&quot;can&#x27;t deliver broadcast&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Application has died. Receiver doesn&#x27;t exist.</span><br><span class="line">            throw new RemoteException(&quot;app.thread must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</span><br><span class="line">                sticky, sendingUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>app.thread就是ActivityThread的一个代理对象，通过它就可以调用ActivityThread的scheduleRegisteredReceiver方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// This function exists to make sure all receiver dispatching is</span><br><span class="line">// correctly ordered, since these are one-way calls and the binder driver</span><br><span class="line">// applies transaction ordering per object for such calls.</span><br><span class="line">public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,</span><br><span class="line">        int resultCode, String dataStr, Bundle extras, boolean ordered,</span><br><span class="line">        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;</span><br><span class="line">    updateProcessState(processState, false);</span><br><span class="line">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续调用IIntentReceiver.performReceive方法来完成后续动作，又将逻辑切回到了我们注册广播时的LoadedApk.ReceiverDispatcher的performReceive中，这就回到了注册广播的主线程了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void performReceive(Intent intent, int resultCode, String data,</span><br><span class="line">        Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;</span><br><span class="line">    //创建了一个Args对象，Args实现了Runable接口    </span><br><span class="line">    final Args args = new Args(intent, resultCode, data, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">    if (intent == null) &#123;</span><br><span class="line">        Log.wtf(TAG, &quot;Null intent received&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">            int seq = intent.getIntExtra(&quot;seq&quot;, -1);</span><br><span class="line">            Slog.i(ActivityThread.TAG, &quot;Enqueueing broadcast &quot; + intent.getAction()</span><br><span class="line">                    + &quot; seq=&quot; + seq + &quot; to &quot; + mReceiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //mActivityThread是 ActivityThread#mH</span><br><span class="line">    if (intent == null || !mActivityThread.post(args)) &#123;</span><br><span class="line">        if (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">            if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    &quot;Finishing sync broadcast to &quot; + mReceiver);</span><br><span class="line">            args.sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了一个Args对象，Args实现了Runnable接口，然后mActivityThread.post(args)将这个Runnable 抛给了mH，Args的run方法实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    ......</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;broadcastReceiveReg&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        ClassLoader cl =  mReceiver.getClass().getClassLoader();</span><br><span class="line">        intent.setExtrasClassLoader(cl);</span><br><span class="line">        intent.prepareToEnterProcess();</span><br><span class="line">        setExtrasClassLoader(cl);</span><br><span class="line">        receiver.setPendingResult(this);</span><br><span class="line">        </span><br><span class="line">        //直接通过注册时的引用，调用其onReceive方法</span><br><span class="line">        receiver.onReceive(mContext, intent);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    &quot;Finishing failed broadcast to &quot; + mReceiver);</span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mInstrumentation == null ||</span><br><span class="line">                !mInstrumentation.onException(mReceiver, e)) &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Error receiving broadcast &quot; + intent</span><br><span class="line">                + &quot; in &quot; + mReceiver, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (receiver.getPendingResult() != null) &#123;</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里终于看到了广播接受者的onReceive(mContext, intent)方法被执行了。mParallelBroadcasts的处理逻辑分析完了，接下来分析mOrderedBroadcasts的处理逻辑，从前面广播注册的逻辑得知，mOrderedBroadcasts包含所有静态注册的广播和动态注册的有序广播，其中动态注册的有序广播的处理逻辑与前面无序的处理过程类似。现在重点看下静态注册的广播，从processNextBroadcast方法中可以看到是调用了processCurBroadcastLocked来处理mOrderedBroadcasts中静态注册的广播。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private final void processCurBroadcastLocked(BroadcastRecord r,</span><br><span class="line">        ProcessRecord app) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">    r.receiver = app.thread.asBinder();</span><br><span class="line">    r.curApp = app;</span><br><span class="line">    app.curReceiver = r;</span><br><span class="line">    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_RECEIVER);</span><br><span class="line">    mService.updateLruProcessLocked(app, false, null);</span><br><span class="line">    mService.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">    // Tell the application to launch this receiver.</span><br><span class="line">    r.intent.setComponent(r.curComponent);</span><br><span class="line"></span><br><span class="line">    boolean started = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">                &quot;Delivering to component &quot; + r.curComponent</span><br><span class="line">                + &quot;: &quot; + r);</span><br><span class="line">        mService.notifyPackageUse(r.intent.getComponent().getPackageName(),</span><br><span class="line">                                  PackageManager.NOTIFY_PACKAGE_USE_BROADCAST_RECEIVER);</span><br><span class="line">        //关键代码</span><br><span class="line">        app.thread.scheduleReceiver(new Intent(r.intent), r.curReceiver,</span><br><span class="line">                mService.compatibilityInfoForPackageLocked(r.curReceiver.applicationInfo),</span><br><span class="line">                r.resultCode, r.resultData, r.resultExtras, r.ordered, r.userId,</span><br><span class="line">                app.repProcState);</span><br><span class="line">        if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                &quot;Process cur broadcast &quot; + r + &quot; DELIVERED for app &quot; + app);</span><br><span class="line">        started = true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (!started) &#123;</span><br><span class="line">            if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                    &quot;Process cur broadcast &quot; + r + &quot;: NOT STARTED!&quot;);</span><br><span class="line">            r.receiver = null;</span><br><span class="line">            r.curApp = null;</span><br><span class="line">            app.curReceiver = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过ActivityThread的代理对象app.thread调用其scheduleReceiver方法，其实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleReceiver(Intent intent, ActivityInfo info,</span><br><span class="line">        CompatibilityInfo compatInfo, int resultCode, String data, Bundle extras,</span><br><span class="line">        boolean sync, int sendingUser, int processState) &#123;</span><br><span class="line">    updateProcessState(processState, false);</span><br><span class="line">    ReceiverData r = new ReceiverData(intent, resultCode, data, extras,</span><br><span class="line">            sync, false, mAppThread.asBinder(), sendingUser);</span><br><span class="line">    r.info = info;</span><br><span class="line">    r.compatInfo = compatInfo;</span><br><span class="line">    sendMessage(H.RECEIVER, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void sendMessage(int what, Object obj) &#123;</span><br><span class="line">        sendMessage(what, obj, 0, 0, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">        TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)</span><br><span class="line">        + &quot;: &quot; + arg1 + &quot; / &quot; + obj);</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    if (async) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终通过mH发送了一条H.RECEIVER消息，对应what为RECEIVER的处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">case RECEIVER:</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;broadcastReceiveComp&quot;);</span><br><span class="line">    handleReceiver((ReceiverData)msg.obj);</span><br><span class="line">    maybeSnapshot();</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    break;</span><br><span class="line">                    </span><br></pre></td></tr></table></figure>
<p>紧接着调用handleReceiver来处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">private void handleReceiver(ReceiverData data) &#123;</span><br><span class="line">    // If we are getting ready to gc after going to the background, well</span><br><span class="line">    // we are back active so skip it.</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">    String component = data.intent.getComponent().getClassName();</span><br><span class="line"></span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line"></span><br><span class="line">    BroadcastReceiver receiver;</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        data.intent.setExtrasClassLoader(cl);</span><br><span class="line">        data.intent.prepareToEnterProcess();</span><br><span class="line">        data.setExtrasClassLoader(cl);</span><br><span class="line">        </span><br><span class="line">        //创建了一个广播接收者实例</span><br><span class="line">        receiver = (BroadcastReceiver)cl.loadClass(component).newInstance();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (DEBUG_BROADCAST) Slog.i(TAG,</span><br><span class="line">                &quot;Finishing failed broadcast to &quot; + data.intent.getComponent());</span><br><span class="line">        data.sendFinished(mgr);</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">            &quot;Unable to instantiate receiver &quot; + component</span><br><span class="line">            + &quot;: &quot; + e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Application app = packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        if (localLOGV) Slog.v(</span><br><span class="line">            TAG, &quot;Performing receive of &quot; + data.intent</span><br><span class="line">            + &quot;: app=&quot; + app</span><br><span class="line">            + &quot;, appName=&quot; + app.getPackageName()</span><br><span class="line">            + &quot;, pkg=&quot; + packageInfo.getPackageName()</span><br><span class="line">            + &quot;, comp=&quot; + data.intent.getComponent().toShortString()</span><br><span class="line">            + &quot;, dir=&quot; + packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">        ContextImpl context = (ContextImpl)app.getBaseContext();</span><br><span class="line">        sCurrentBroadcastIntent.set(data.intent);</span><br><span class="line">        receiver.setPendingResult(data);</span><br><span class="line">        </span><br><span class="line">        //广播接收者的onReceive方法被执行了</span><br><span class="line">        receiver.onReceive(context.getReceiverRestrictedContext(),</span><br><span class="line">                data.intent);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (DEBUG_BROADCAST) Slog.i(TAG,</span><br><span class="line">                &quot;Finishing failed broadcast to &quot; + data.intent.getComponent());</span><br><span class="line">        data.sendFinished(mgr);</span><br><span class="line">        if (!mInstrumentation.onException(receiver, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to start receiver &quot; + component</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        sCurrentBroadcastIntent.set(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (receiver.getPendingResult() != null) &#123;</span><br><span class="line">        data.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态注册的广播接收者通常是没有运行的，所以在这里先是创建了一个接收者的实例，然后调用它的onReceive方法。</p>
<h1 id="三-总结："><a href="#三-总结：" class="headerlink" title="三.总结："></a>三.总结：</h1><ol>
<li><p>静态注册注册的广播，在PMS启动的时候扫描系统中安装的apk文件，并解析它们的AndroidManifest.xml文件，将所有注册的广播保存在PMS的成员变量mReceivers中；</p>
</li>
<li><p>动态注册的广播存储在AMS的成员变量mRegisteredReceivers中；</p>
</li>
<li><p>发送广播的处理逻辑在AMS中，AMS负责从mReceivers和mRegisteredReceivers这两个集合查询出与IntentFilter匹配的接收者，并将它们添加到BroadcastQueue的mParallelBroadcasts（动态注册的无序广播）或者mOrderedBroadcasts（有序广播和所有的静态广播）中;</p>
</li>
<li><p>在BroadcastQueue先处理mParallelBroadcasts，所以动态注册的无序广播会先收到广播;</p>
</li>
<li><p>当有应用安装，卸载时（实际的逻辑在PMS中），静态注册的广播自然是在PMS中进行更新注册信息，接着再发送广播到AMS中更新动态注册广播；</p>
</li>
<li><p>动态广播的onReceive方法是在LoadedApk#ReceiverDispatcher#Args的run方法中被调用；静态广播的onReceive是在ActivityThread的handleReceiver方法中被调用，而它们都是跑在目标进程的主线程中。</p>
</li>
</ol>
<p>以上源码均来自 Android25。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/broadcast/" rel="tag"># -broadcast</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2017/09/20/android-broadcast/" rel="prev" title="Android广播那些事儿">
                  <i class="fa fa-chevron-left"></i> Android广播那些事儿
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2017/10/21/ipc/" rel="next" title="IPC基础">
                  IPC基础 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jdqm</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
